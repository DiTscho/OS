
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/OS.ipynb
import numpy as np
import pandas as pd
from path import Path
import re
import matplotlib.pylab as plt
import pandas as pd
pd.options.mode.chained_assignment = None
from sklearn.model_selection import train_test_split
from sklearn.inspection import permutation_importance
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

def load_data(path, columns=None, laser_power=400):
    """laser_power can be 400, 800, 1200, or "pooled"
       label: 1: CTC and 0: PBMC."""
    try:
        X= pd.read_pickle(path/"os_data_"+str(laser_power)+".pkl")
        y= X["y"]
        X= X.drop(columns="y")
        X = X.loc[:,~X.columns.duplicated()]
        if columns==None:
            pass
        else:
            X= X[columns]
    except:
        X,y = [], []
    return X,y

class OpticalStretcher():
    def __init__(self, X ,y): self.X, self.y, self.model= X,y, None

    def split_data(self):
        X_train, X_test, y_train, y_test = train_test_split(self.X,self.y, test_size=0.4, random_state=0)
        return X_train, X_test, y_train, y_test

    def fit(self, X_train, y_train, n_trees):
        m= RandomForestClassifier(n_estimators=n_trees, bootstrap=False, criterion='entropy', random_state=0)
        self.model= m
        return(m)

    def fit_and_predict(self, X_train, X_test, y_train, y_test, n_trees:int=500):
        m= self.fit(X_train,y_train, n_trees)
        m.fit(X_train, y_train)
        return(m.predict(X_test))

    def get_stats(self, y_pred, y_test):
        acc= (y_pred==y_test).mean()
        cm= confusion_matrix(y_test, y_pred)
        se= cm[1,1]/(cm[1,1]+cm[1,0]) #tp/(tp+fn) for 1:cancer, 0:healthy
        sp= cm[0,0]/(cm[0,0]+cm[0,1]) #tn/(tn+fp) for 1:cancer, 0:healthy
        return(acc, se, sp, cm)

    def get_importances(self, X_test, y_test):
        result = permutation_importance(self.model, X_test, y_test, scoring="accuracy", n_repeats=5, random_state=0)
        sorted_idx = result.importances_mean.argsort()
        return result, sorted_idx

    def plot_importances(self, result, sorted_idx, labels, save:bool=False, name:str="fi"):
        fig, ax = plt.subplots(figsize=(20,10))
        ax.boxplot(result.importances[sorted_idx].T, vert=False, labels=labels)
        ax.set_title("Permutation Importances (test set)")
        fig.tight_layout()
        if save==True: plt.savefig(name+".png")
        plt.show()